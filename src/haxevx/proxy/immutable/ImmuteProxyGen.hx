package haxevx.proxy.immutable;

import haxe.macro.ComplexTypeTools;
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.MacroStringTools;
import haxe.macro.Type.ClassKind;
import haxe.macro.TypeTools;
import haxe.macro.Type;

// This is just a Proxy example...
// https://gist.github.com/elsassph/319e1eade1978f08e221
// modified to run under custom Proxied implementation with Abstract Immutable Map/Record set()/get() methods
// It assumes the Abstract will proxy to an immutable extern, that accepts a type parameter representing the plain data type to proxy to.
// It will auto-generate all necessary immutable properties getters/setters accordingly into the existing abstract class based on the supplied plain data type parameter of the Immutable extern.
// The Haxe abstract allows you to handle your own domain-specific methods/accessors/setters and customised access control over ImmutableJS's (or whichever extern you are refering to...) data structure 

/**
 * TODO Roadmap:
 (i figured the below system provides the most flexibility to accomodate different coding situations for different projects...and provide full-blown ImmutableJS type-safety/access-control at compile time)
 *  type-param macro immutable prop generation for Typedef/Interface vs Class data formats: (Typedef/Interface will auto-generate all immutable properties as fully public if not yet already manually defined in abstract class. Class will auto-generate either private/public immutable properties if not already manually defined in abstract class). The immutable properties are  generated in typical "(get, never)+setPropname" format. The underlying immutable typeparam should only contain raw physical data fields to be used for initialization of immutable structures.
 *  Allow also manually defining immutable class properties within abstract class definition  ( get, never )/setPropname with any custom access overwrites within abstract class taking priority over the macro-generated defaults.
 *  Allow self-owned abstract class domain-specific helper getters that are treated as non-properties ( get, never ) if it already includes accompanying get_method() definition within the abstract class.
 *  Compile error checking: All matching class field names (get, never) that matches those in the Immutable typeparam definition (var ...) must also have matching field types and should not have manually defined domain-specific get_method() implementation within the abstract class (since this will be auto-generated by macro).
 *  Allow for @:getOnly metadata on individual abstract class fields to ensure no accompanying setPropname fields will be auto-generated by the macro from underlying typeparam. However, this metadata doesn't stop you from still being able to manually define your own custom domain-specific setPropname() implementation within the abstract class itself. 
 *  @:optionExplicit flag on abstract class header to require explicitly declaring  all immutable properties manually within the abstract class itself to  match supplied underlying typeparam. Only setPropname() methods will be auto-generated unless the specific field implementation within the abstract is marked with @:getOnly. The underlying typeparam therefore acts somwhat like a Haxe interface  and requires manually declaring those immutable properties within the class as well.
 *  Compile error checking: Finally, ensure all property declarations are Immutable (ie. (get, never))..ie. ensure no other physical properties are included into the abstract class implementation (eg. either through "var" or ":isVar"). All physical properties must be kept outside of the Immutable abstract class itself within the typeparam definition.
 */
class ImmuteProxyGen
{
	macro public static function build():Array<Field> 
	{

		var fields = Context.getBuildFields();
		var localClass = Context.getLocalClass();
		var className:String = localClass.get().module ;
		var retMe = MacroStringTools.toComplex(className);
		
		// this sniffing is rather dangerous with 'magic' indexed access, will it work all the time??
		var sniffDataType = TypeTools.followWithAbstracts(ComplexTypeTools.toType(retMe)).getParameters()[1][0];


		var fieldsToAdd:Array<String> = [];
		var fieldTypesToAdd:Array<ComplexType> = [];
		var rrr = TypeTools.follow(sniffDataType);
		switch(  rrr) {
			case Type.TAnonymous(a):
				for (f in a.get().fields) {
					fieldsToAdd.push(f.name);
					fieldTypesToAdd.push(TypeTools.toComplexType(f.type));
				}
			case Type.TInst(a, params):

				for (f in a.get().fields.get() ) {
					fieldsToAdd.push(f.name);
					fieldTypesToAdd.push(TypeTools.toComplexType(f.type));
				}
			default:
				trace("TODO: need to support:" + rrr);
		}
		
		for (i in 0...fieldsToAdd.length) {
				var name:String = fieldsToAdd[i];
				var fieldType:ComplexType = fieldTypesToAdd[i];
			
				var getterFunc:Function = { 
					args: [], 
					expr: macro return get($v{name}), 
					ret: fieldType 
				};
				
				fields.push( {
				  name:  name,
				  access: [Access.APublic],
				  kind: FieldType.FProp("get", "never", getterFunc.ret), 
				  pos: Context.currentPos(),
				});
				
				
				fields.push({
					name: 'get_' + name,
					access: [Access.APrivate, Access.AInline],
					kind: FieldType.FFun(getterFunc),
					pos: Context.currentPos()
				});
				
					
			
				
				fields.push({
					name: 'set' + formatName(name),
					access: [Access.APublic, Access.AInline],
					kind: FieldType.FFun({ 
						args: [{ name:'value', type:fieldType  } ], 
						expr: macro return set($v{name}, value), 
						ret:  null 
					}),
					pos: Context.currentPos()
				});
				
			
			
				
				
				
		}
		
		

		fields.push( {
			name: 'get',
			access: [Access.APublic, Access.AInline],
			kind: FieldType.FFun({ 
				args: [{ name:'prop', type:null } ], 
				expr: macro return  this.get(prop), 
				ret: null 
			}),
			pos: Context.currentPos()
			
		});
		
		///*
		fields.push( {
			name: 'set',
			access: [Access.APublic, Access.AInline],
			kind: FieldType.FFun({ 
				args: [{ name:'prop', type: (macro:String)  }, { name:'val', type: (macro:Dynamic) } ], 
				expr: macro return  this.set(prop, val), 
				ret:  retMe //TypeTools.toComplexType(Context.getLocalType()) 
			}),
			pos: Context.currentPos()
			
		});
		//*/
		

		return fields;
	}
	
	static inline function formatName(name:String) 
	{
		return name.charAt(0).toUpperCase() + name.substr(1);
	}
	

	

}